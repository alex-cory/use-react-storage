"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const STATEMENT_LIST_PARENTS = new Set([
    'Program',
    'BlockStatement',
    'SwitchCase',
    'SwitchStatement',
]);
const isTokenOnSameLine = (left, right) => left.loc.end.line === right.loc.start.line;
const isSemicolonToken = (token) => token.value === ';' && token.type === 'Punctuator';
const isTestFile = (filename) => filename.includes('test') || filename.includes('spec');
function newJestTokenTester(name) {
    return {
        test: (node, sourceCode) => {
            const token = sourceCode.getFirstToken(node);
            return (node.type === 'ExpressionStatement' &&
                token.type === 'Identifier' &&
                token.value === name);
        },
    };
}
function getActualLastToken(sourceCode, node) {
    const semiToken = sourceCode.getLastToken(node);
    const prevToken = sourceCode.getTokenBefore(semiToken);
    const nextToken = sourceCode.getTokenAfter(semiToken);
    const isSemicolonLessStyle = Boolean(prevToken &&
        nextToken &&
        prevToken.range[0] >= node.range[0] &&
        isSemicolonToken(semiToken) &&
        semiToken.loc.start.line !== prevToken.loc.end.line &&
        semiToken.loc.end.line === nextToken.loc.start.line);
    return isSemicolonLessStyle ? prevToken : semiToken;
}
function verifyForAlways(context, prevNode, nextNode, paddingLines) {
    if (paddingLines.length > 0) {
        return;
    }
    context.report({
        node: nextNode,
        message: 'Expected blank line before this statement.',
        fix(fixer) {
            const sourceCode = context.getSourceCode();
            let prevToken = getActualLastToken(sourceCode, prevNode);
            const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {
                includeComments: true,
                filter(token) {
                    if (isTokenOnSameLine(prevToken, token)) {
                        prevToken = token;
                        return false;
                    }
                    return true;
                },
            }) || nextNode;
            const insertText = isTokenOnSameLine(prevToken, nextToken)
                ? '\n\n'
                : '\n';
            return fixer.insertTextAfter(prevToken, insertText);
        },
    });
}
const PaddingTypes = {
    any: { verify: () => { } },
    always: { verify: verifyForAlways },
};
const StatementTypes = {
    '*': { test: () => true },
    afterAll: newJestTokenTester('afterAll'),
    afterEach: newJestTokenTester('afterEach'),
    beforeAll: newJestTokenTester('beforeAll'),
    beforeEach: newJestTokenTester('beforeEach'),
    describe: newJestTokenTester('describe'),
    expect: newJestTokenTester('expect'),
    it: newJestTokenTester('it'),
    test: newJestTokenTester('test'),
};
exports.default = {
    meta: {
        fixable: 'whitespace',
        schema: {
            definitions: {
                paddingType: {
                    enum: Object.keys(PaddingTypes),
                },
                statementType: {
                    anyOf: [
                        { enum: Object.keys(StatementTypes) },
                        {
                            type: 'array',
                            items: { enum: Object.keys(StatementTypes) },
                            minItems: 1,
                            uniqueItems: true,
                            additionalItems: false,
                        },
                    ],
                },
            },
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    blankLine: { $ref: '#/definitions/paddingType' },
                    prev: { $ref: '#/definitions/statementType' },
                    next: { $ref: '#/definitions/statementType' },
                },
                additionalProperties: false,
                required: ['blankLine', 'prev', 'next'],
            },
            additionalItems: false,
        },
    },
    create(context) {
        const filename = context.getFilename();
        if (!isTestFile(filename)) {
            return {};
        }
        const sourceCode = context.getSourceCode();
        const configureList = context.options || [];
        let scopeInfo = null;
        function enterScope() {
            scopeInfo = { upper: scopeInfo, prevNode: null };
        }
        function exitScope() {
            scopeInfo = scopeInfo.upper;
        }
        function match(node, type) {
            let innerStatementNode = node;
            while (innerStatementNode.type === 'LabeledStatement') {
                innerStatementNode = innerStatementNode.body;
            }
            if (Array.isArray(type)) {
                return type.some(match.bind(null, innerStatementNode));
            }
            return StatementTypes[type].test(innerStatementNode, sourceCode);
        }
        function getPaddingType(prevNode, nextNode) {
            for (let i = configureList.length - 1; i >= 0; --i) {
                const { prev, next, blankLine } = configureList[i];
                if (match(prevNode, prev) && match(nextNode, next)) {
                    return PaddingTypes[blankLine];
                }
            }
            return PaddingTypes.any;
        }
        function getPaddingLineSequences(prevNode, nextNode) {
            const pairs = [];
            let prevToken = getActualLastToken(sourceCode, prevNode);
            if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {
                do {
                    const token = sourceCode.getTokenAfter(prevToken, {
                        includeComments: true,
                    });
                    if (token.loc.start.line - prevToken.loc.end.line >= 2) {
                        pairs.push([prevToken, token]);
                    }
                    prevToken = token;
                } while (prevToken.range[0] < nextNode.range[0]);
            }
            return pairs;
        }
        function verify(node) {
            const parentType = node.parent.type;
            const validParent = STATEMENT_LIST_PARENTS.has(parentType);
            if (!validParent) {
                return;
            }
            const { prevNode } = scopeInfo;
            if (prevNode) {
                const type = getPaddingType(prevNode, node);
                const paddingLines = getPaddingLineSequences(prevNode, node);
                type.verify(context, prevNode, node, paddingLines);
            }
            scopeInfo.prevNode = node;
        }
        function verifyThenEnterScope(node) {
            verify(node);
            enterScope();
        }
        return {
            Program: enterScope,
            BlockStatement: enterScope,
            SwitchStatement: enterScope,
            'Program:exit': exitScope,
            'BlockStatement:exit': exitScope,
            'SwitchStatement:exit': exitScope,
            ':statement': verify,
            SwitchCase: verifyThenEnterScope,
            'SwitchCase:exit': exitScope,
        };
    },
};
